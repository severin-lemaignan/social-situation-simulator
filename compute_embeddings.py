#! python3

import pandas as pd
import numpy as np
import random
from pathlib import Path
import argparse

random.seed(10)

from langchain.embeddings import OpenAIEmbeddings
from langchain.embeddings import LlamaCppEmbeddings

from analyse import DEFAULT_INTERPOLATION_FREQUENCY, DEFAULT_WINDOW_LENGTH

CONTEXT = "This is the description of a social setting with a few people: {desc}. We want to generate a good description of the situation."

NAMES = [
    "Alice",
    "Oliver",
    "Phoebe",
    "George",
    "Matilda",
    "William",
    "Charlotte",
    "Jack",
    "Jessica",
    "James",
    "Lucy",
    "Thomas",
    "Charlie",
    "Harry",
    "Henry",
    "Alexander",
    "Benjamin",
    "Daniel",
    "Michael",
    "David",
    "Joseph",
    "Matthew",
    "Andrew",
    "Edward",
    "Samuel",
    "Robert",
    "Christopher",
    "Stephen",
    "Richard",
    "Peter",
    "Anthony",
    "Jonathan",
    "Simon",
    "Patrick",
    "Alan",
    "Paul",
    "Nicholas",
    "Timothy",
    "Philip",
    "Francis",
    "Brian",
    "Kevin",
    "Martin",
    "Keith",
    "Graham",
    "Terry",
    "Barry",
    "Derek",
    "Adrian",
    "Wayne",
    "Gary",
    "Stuart",
    "Malcolm",
    "Gavin",
    "Darren",
    "Lee",
    "Olivia",
    "Amelia",
    "Isla",
    "Ava",
    "Emily",
    "Sophia",
    "Lily",
    "Isabella",
    "Mia",
    "Poppy",
    "Ella",
    "Grace",
    "Freya",
    "Scarlett",
    "Chloe",
    "Daisy",
    "Alice",
    "Phoebe",
    "Matilda",
    "Charlotte",
    "Jessica",
    "Lucy",
    "Rosie",
    "Hannah",
    "Ruby",
    "Evelyn",
    "Zoe",
    "Abigail",
    "Erin",
    "Eleanor",
    "Megan",
    "Elizabeth",
    "Victoria",
    "Laura",
    "Rachel",
    "Rebecca",
    "Nicola",
    "Louise",
    "Jennifer",
    "Susan",
    "Karen",
    "Christine",
    "Pamela",
    "Wendy",
    "Angela",
    "Alison",
    "Sharon",
    "Donna",
    "Sandra",
    "Diane",
]


def realise_names(desc, randomise=True):

    if randomise:
        mapping = {k: random.choice(NAMES) for k in "ABCDEFGHIJKLMNOPQRSTUVW"}
    else:
        mapping = {k: NAMES[i] for i, k in enumerate("ABCDEFGHIJKLMNOPQRSTUVW")}

    return [d.format(**mapping) for d in desc]


def generate_variations(desc, max=5):

    # add variations of the same description
    tokens = [x.strip() for x in desc.split(";")]

    variations = []

    for _ in range(max):
        random.shuffle(tokens)
        variation = "; ".join(tokens)
        if variation not in variations and variation != desc:
            variations.append(variation)

    return variations


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Extract social scene descriptions and compute corresponding embeddings"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="if set, does not actually compute embeddings, using fake static data instead. No data is saved either.",
    )

    parser.add_argument(
        "-s",
        "--sampling-rate",
        type=float,
        nargs="?",
        default=DEFAULT_INTERPOLATION_FREQUENCY,
        help="(Hz) resampling rate of the situation. Default to %sHz."
        % DEFAULT_INTERPOLATION_FREQUENCY,
    )
    parser.add_argument(
        "-l",
        "--window-length",
        type=float,
        nargs="?",
        default=DEFAULT_WINDOW_LENGTH,
        help="(secs) length of the window for which descriptions are generated before each point. Default to %ss."
        % DEFAULT_WINDOW_LENGTH,
    )
    parser.add_argument(
        "--random-names",
        action="store_true",
        help="if set, the descriptions all use different names. If not, always the same names are used.",
    )

    parser.add_argument(
        "-v",
        "--max-variations",
        type=int,
        default=0,
        help="The maximum number that variations of each description should be generated. Default to 0.",
    )

    parser.add_argument(
        "src",
        type=str,
        help="CSV file containing all the situation descriptions, as generated by analyse.py",
    )

    parser.add_argument(
        "dest",
        type=str,
        help="CSV file containing the computed embeddings. If the file already exists, embeddings for new descriptions will be added to it.",
    )

    args = parser.parse_args()

    embeddings_model = OpenAIEmbeddings()
    # embeddings_model = LlamaCppEmbeddings(
    #    model_path="/home/severinlemaignan/src/llama.cpp/models/llama-2-13b-chat.ggmlv3.q4_0.bin"
    # )

    df = pd.read_csv(args.src)

    # pre-load previous embeddings
    if Path(args.dest).exists():
        print("%s already exist. Adding new embeddings to it." % args.dest)
        embeddings_df = pd.read_csv(args.dest, index_col=0)
        embeddings = {
            row["template"]: row.to_dict() for _, row in embeddings_df.iterrows()
        }
    else:
        embeddings = {}

    ts = np.arange(0, args.window_length + 0.001, 1 / args.sampling_rate)

    groups = []
    all_descriptions = list(embeddings.keys())

    new_embeddings = 0
    for _, row in df.iterrows():

        engaged = row["engaged"]
        actual_ts = row["actual_ts"]
        viewed_by = row["viewed_by"]
        for t in ts:
            desc = row["t-%s" % t]
            short_code = row["t-%s-short-code" % t]

            if desc not in groups:
                groups.append(desc)

            group_id = groups.index(desc)

            variations = [desc] + generate_variations(desc, max=args.max_variations)

            for desc in variations:
                if desc in all_descriptions:
                    # do not recomputed the embedding, but update the 'engaged' status if it is 'true'
                    if t == 0.0 and engaged:
                        embeddings[desc]["engaged"] = engaged
                    continue

                all_descriptions.append(desc)

                new_embeddings += 1
                realised_desc, realised_viewed = realise_names(
                    [desc, viewed_by], randomise=args.random_names
                )
                print("Computing embedding of <%s>..." % realised_desc)

                if args.dry_run:
                    emb = [0.1, 0.001, 0.81, 0.92]
                else:
                    emb = embeddings_model.embed_query(
                        CONTEXT.format(desc=realised_desc)
                    )

                embeddings[desc] = {
                    "group": group_id,
                    "engaged": engaged if t == 0.0 else 0,
                    "ts": actual_ts - t,
                    "viewed_by": viewed_by,
                    "viewed_by_name": realised_viewed,
                    "template": desc,
                    "desc": realised_desc,
                    "short_code": short_code,
                }
                for i, v in enumerate(emb):
                    embeddings[desc][str(i)] = v

    df_embeddings = pd.DataFrame.from_dict(embeddings, orient="index").reset_index(
        drop=True
    )

    print("Computed %s new embeddings" % new_embeddings)
    if args.dry_run:
        print("DRY RUN, not saving the data")
        print(df_embeddings)
    else:
        df_embeddings.to_csv(args.dest)
        print("Successfully saved embeddings to %s" % args.dest)

    # for g in groups:
    #    print(g)
